// TODO: do we need to support `feeTo`???
Contract UniswapV2Factory(
  pairTemplateId: ByteVec, // the template contract id of `UniswapV2Pair`
  mut pairSize: U256
) extends Constants() {

  event PairCreated(token0: ByteVec, token1: ByteVec, pair: ByteVec, currentPairSize: U256)

  @using(updateFields = false)
  fn sortTokens(tokenA: ByteVec, tokenB: ByteVec) -> (ByteVec, ByteVec) {
    let left = u256From32Byte!(tokenA)
    let right = u256From32Byte!(tokenB)
    if (left < right) {
      return tokenA, tokenB
    }
    return tokenB, tokenA
  }

  @using(preapprovedAssets = true)
  pub fn createPair(
    payer: Address,
    alphAmount: U256,
    tokenAId: ByteVec,
    tokenBId: ByteVec
  ) -> () {
    assert!(tokenAId != tokenBId, ErrorCodes.IdenticalTokenIds)
    let (token0Id, token1Id) = sortTokens(tokenAId, tokenBId)
    let encodedFields = encodeToByteVec!(
      token0Id,
      token1Id,
      0,                   // reserve0
      0,                   // reserve1
      0,                   // blockTimeStampLast
      0,                   // price0CumulativeLast
      0,                   // price1CumulativeLast
      0                    // totalSupply
    )
    let pairId = copyCreateSubContractWithToken!{payer -> alphAmount}(
      token0Id ++ token1Id,
      pairTemplateId,
      encodedFields,
      1 << 255
    )

    emit PairCreated(token0Id, token1Id, pairId, pairSize)

    pairSize = pairSize + 1
  }
}
